// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable function_body_length
// swiftlint:disable type_body_length

internal final class Elevation {
    internal let client: ElevationClientInternal

    init(client: ElevationClientInternal) {
        self.client = client
    }

    /// **Applies to**: S1 pricing tier.
    ///  The Get Data for Points API provides elevation data for one or more points.  A point is defined in lat,long coordinate format.
    ///  Due to the URL character  length limit of 2048, it's not possible to pass more than 100 coordinates  as a pipeline delimited string in a URL GET request. If you intend to pass  more than 100 coordinates as a pipeline delimited string, use the [POST Data
    ///  For Points](https://docs.microsoft.com/rest/api/maps/elevation/postdataforpoints).
    ///  The result will be in the same sequence of points listed in the request.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - points : The string representation of a list of points. A point is defined in lon/lat WGS84 coordinate reference system format.  If multiple points are requested, each of the points in a list should be separated by the pipe ('|') character.  The maximum number of points that can be requested in a single request is 2,000. The resolution of the elevation  data will be the highest for a single point and will decrease if multiple points are spread further apart.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getDataForPoints(
        format: JsonFormat,
        points: [String],
        withOptions options: GetDataForPointsOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<ElevationResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "points", points.map { $0 }.joined(separator: "|"), .skipEncoding),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/elevation/point/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ElevationResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S1 pricing tier.
    ///  The Post Data for Points API provides elevation data for multiple points.  A point is defined lon/lat coordinate format.
    ///  Use the POST endpoint only if you intend to pass multiple points in the request. If you intend to pass  a single coordinate into the API, use the [GET Data For Points API](https://docs.microsoft.com/rest/api/maps/elevation/getdataforpoints).
    ///  The result will be in the same sequence of points listed in the request.
    /// - Parameters:
    ///    - dataForPoints : The string representation of a list of points. A point is defined in lon/lat WGS84 coordinate reference system format.  Each points in a list should be separated by the pipe ('|') character. The number of points that can be requested in  a POST request ranges from 2 to 2,000. The resolution of the elevation data will be the highest for a single point  and will decrease if multiple points are spread further apart.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func post(
        dataForPoints: [LatLongPairAbbreviated],
        format: JsonFormat,
        withOptions options: PostDataForPointsOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<ElevationResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(dataForPoints) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/elevation/point/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ElevationResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S1 pricing tier.
    ///  The Get Data for Polyline API provides elevation data along a polyline.
    ///  A polyline is defined by passing in between 2 and N endpoint coordinates separated by a pipe ('|') character. In addition to passing in endpoints, customers can specify the number of sample points that will be used to divide polyline into equally spaced segments.
    ///  Elevation data at both start and endpoints, as well as equally spaced points along the polyline will be returned. The results will be listed in the direction from the first endpoint towards the last endpoint. A line between two endpoints is a straight Cartesian line, the  shortest line between those two points in the coordinate reference system. Note that the point is  chosen based on Euclidean distance and may markedly differ from the geodesic path along the curved  surface of the reference ellipsoid.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - lines : The string representation of a polyline path. A polyline is defined by endpoint coordinates,  with each endpoint separated by a pipe ('|') character. The polyline should be defined in the  following format: `[longitude_point1, latitude_point1 | longitude_point2, latitude_point2, ...,  longitude_pointN, latitude_pointN]`.
    ///  The longitude and latitude values refer to the World Geodetic  System (WGS84) coordinate reference system. The resolution of the data used to compute the  elevation depends on the distance between the endpoints.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getDataForPolyline(
        format: JsonFormat,
        lines: [String],
        withOptions options: GetDataForPolylineOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<ElevationResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "lines", lines.map { $0 }.joined(separator: "|"), .skipEncoding),
            (.query, "samples", options?.samples, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/elevation/line/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate samples
        if let samples = options?.samples, samples > 2000 {
            validationErrors.append("samples: <= 2000")
        }
        if let samples = options?.samples, samples < 2 {
            validationErrors.append("samples: >= 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ElevationResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S1 pricing tier.
    ///  The Post Data for Polyline API provides elevation data along a polyline.
    ///  A polyline is defined by  passing in between 2 and N endpoint coordinates separated by a pipe ('|') character. In addition  to passing in endpoints, customers can specify the number of sample points that will be used to divide polyline into equally spaced segments.
    ///  Elevation data at both start and end points, as well as equally spaced  points along the polyline will be returned. The results will be listed in the direction from the first endpoint towards the last endpoint. A line between two endpoints is a straight Cartesian line, the  shortest line between those two points in the coordinate reference system. Note that the point is  chosen based on Euclidean distance and may markedly differ from the geodesic path along the curved surface of the reference ellipsoid.
    /// - Parameters:
    ///    - dataForPolyline : The string representation of a polyline path. A polyline is defined by endpoint coordinates,  with each endpoint separated by a pipe ('|') character. The polyline should be defined in the  following format: `[longitude_point1, latitude_point1 | longitude_point2, latitude_point2, ...,  longitude_pointN, latitude_pointN]`. The longitude and latitude values refer to the World Geodetic  System (WGS84) coordinate reference system. The resolution of the data used to compute the  elevation will depend on the distance between the endpoints.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func post(
        dataForPolyline: [LatLongPairAbbreviated],
        format: JsonFormat,
        withOptions options: PostDataForPolylineOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<ElevationResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "samples", options?.samples, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(dataForPolyline) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/elevation/line/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate samples
        if let samples = options?.samples, samples > 2000 {
            validationErrors.append("samples: <= 2000")
        }
        if let samples = options?.samples, samples < 2 {
            validationErrors.append("samples: >= 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ElevationResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S1 pricing tier.
    /// The Get Data for Bounding Box API provides elevation data at equally spaced locations within a bounding box. A bounding box is defined by the coordinates for two corners (southwest, northeast) and then subsequently  divided into rows and columns.
    ///  Elevations are returned for the vertices of the grid created by the rows and  columns. Up to 2,000 elevations can be returned in a single request. The returned elevation values are ordered,  starting at the southwest corner, and then proceeding west to east along the row. At the end of the row,  it moves north to the next row, and repeats the process until it reaches the far northeast corner.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - bounds : The string that represents the rectangular area of a bounding box. The bounds parameter is defined by the 4 bounding box coordinates, with WGS84 longitude and latitude of the southwest corner followed by  WGS84 longitude and latitude of the northeast corner. The string is presented in the following  format: `[SouthwestCorner_Longitude, SouthwestCorner_Latitude, NortheastCorner_Longitude,  NortheastCorner_Latitude]`.
    ///    - rows : Specifies the number of rows to use to divide the bounding box area into a grid. The number of vertices (rows x columns) in the grid should be less than 2,000.
    ///    - columns : Specifies the number of columns to use to divide the bounding box area into a grid. The number of vertices (rows x columns) in the grid should be less than 2,000.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getDataForBoundingBox(
        format: JsonFormat,
        bounds: [Float],
        rows: Int32,
        columns: Int32,
        withOptions options: GetDataForBoundingBoxOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<ElevationResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "bounds", bounds.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "rows", rows, .encode), (.query, "columns", columns, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/elevation/lattice/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate bounds
        if bounds.count > 4 {
            validationErrors.append("bounds: maxItems 4")
        }
        if bounds.count < 4 {
            validationErrors.append("bounds: minItems 4")
        }
        // Validate columns
        if columns > 1000 {
            validationErrors.append("columns: <= 1000")
        }
        if columns < 2 {
            validationErrors.append("columns: >= 2")
        }
        // Validate rows
        if rows > 1000 {
            validationErrors.append("rows: <= 1000")
        }
        if rows < 2 {
            validationErrors.append("rows: >= 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ElevationResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }
}

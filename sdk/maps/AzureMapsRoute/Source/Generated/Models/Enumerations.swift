// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation

public enum JsonFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259)
    case json

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .json:
            return "json"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "json":
            self = .json
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum ComputeTravelTime: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Does not compute additional travel times.
    case none
    /// Computes travel times for all types of traffic information and specifies all results in the fields noTrafficTravelTimeInSeconds, historicTrafficTravelTimeInSeconds and liveTrafficIncidentsTravelTimeInSeconds being included in the summaries in the route response.
    case all

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .none:
            return "none"
        case .all:
            return "all"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "none":
            self = .none
        case "all":
            self = .all
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum SectionType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Sections of the route that are cars or trains.
    case carOrTrain
    /// Sections indicating which countries the route is in.
    case country
    /// Sections of the route that are ferries.
    case ferry
    /// Sections of the route that are motorways.
    case motorway
    /// Sections of the route that are only suited for pedestrians.
    case pedestrian
    /// Sections of the route that require a toll to be payed.
    case tollRoad
    /// Sections of the route that require a toll vignette to be present.
    case tollVignette
    /// Sections of the route that contain traffic information.
    case traffic
    /// Sections in relation to the request parameter `travelMode`.
    case travelMode
    /// Sections of the route that are tunnels.
    case tunnel
    /// Sections of the route that require use of carpool (HOV/High Occupancy Vehicle) lanes.
    case carpool
    /// Sections of the route that are located within urban areas.
    case urban

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .carOrTrain:
            return "carTrain"
        case .country:
            return "country"
        case .ferry:
            return "ferry"
        case .motorway:
            return "motorway"
        case .pedestrian:
            return "pedestrian"
        case .tollRoad:
            return "tollRoad"
        case .tollVignette:
            return "tollVignette"
        case .traffic:
            return "traffic"
        case .travelMode:
            return "travelMode"
        case .tunnel:
            return "tunnel"
        case .carpool:
            return "carpool"
        case .urban:
            return "urban"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "cartrain":
            self = .carOrTrain
        case "country":
            self = .country
        case "ferry":
            self = .ferry
        case "motorway":
            self = .motorway
        case "pedestrian":
            self = .pedestrian
        case "tollroad":
            self = .tollRoad
        case "tollvignette":
            self = .tollVignette
        case "traffic":
            self = .traffic
        case "travelmode":
            self = .travelMode
        case "tunnel":
            self = .tunnel
        case "carpool":
            self = .carpool
        case "urban":
            self = .urban
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum WindingnessLevel: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// low
    case low
    /// normal
    case normal
    /// high
    case high

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .low:
            return "low"
        case .normal:
            return "normal"
        case .high:
            return "high"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "low":
            self = .low
        case "normal":
            self = .normal
        case "high":
            self = .high
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum InclineLevel: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// low
    case low
    /// normal
    case normal
    /// high
    case high

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .low:
            return "low"
        case .normal:
            return "normal"
        case .high:
            return "high"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "low":
            self = .low
        case "normal":
            self = .normal
        case "high":
            self = .high
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum TravelMode: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// The returned routes are optimized for cars.
    case car
    /// The returned routes are optimized for commercial vehicles, like for trucks.
    case truck
    /// The returned routes are optimized for taxis. BETA functionality.
    case taxi
    /// The returned routes are optimized for buses, including the use of bus only lanes. BETA functionality.
    case bus
    /// The returned routes are optimized for vans. BETA functionality.
    case van
    /// The returned routes are optimized for motorcycles. BETA functionality.
    case motorcycle
    /// The returned routes are optimized for bicycles, including use of bicycle lanes.
    case bicycle
    /// The returned routes are optimized for pedestrians, including the use of sidewalks.
    case pedestrian

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .car:
            return "car"
        case .truck:
            return "truck"
        case .taxi:
            return "taxi"
        case .bus:
            return "bus"
        case .van:
            return "van"
        case .motorcycle:
            return "motorcycle"
        case .bicycle:
            return "bicycle"
        case .pedestrian:
            return "pedestrian"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "car":
            self = .car
        case "truck":
            self = .truck
        case "taxi":
            self = .taxi
        case "bus":
            self = .bus
        case "van":
            self = .van
        case "motorcycle":
            self = .motorcycle
        case "bicycle":
            self = .bicycle
        case "pedestrian":
            self = .pedestrian
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum RouteAvoidType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Avoids toll roads.
    case tollRoads
    /// Avoids motorways
    case motorways
    /// Avoids ferries
    case ferries
    /// Avoids unpaved roads
    case unpavedRoads
    /// Avoids routes that require the use of carpool (HOV/High Occupancy Vehicle) lanes.
    case carpools
    /// Avoids using the same road multiple times. Most useful in conjunction with `routeType`=thrilling.
    case alreadyUsedRoads
    /// Avoids border crossings in route calculation.
    case borderCrossings

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .tollRoads:
            return "tollRoads"
        case .motorways:
            return "motorways"
        case .ferries:
            return "ferries"
        case .unpavedRoads:
            return "unpavedRoads"
        case .carpools:
            return "carpools"
        case .alreadyUsedRoads:
            return "alreadyUsedRoads"
        case .borderCrossings:
            return "borderCrossings"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "tollroads":
            self = .tollRoads
        case "motorways":
            self = .motorways
        case "ferries":
            self = .ferries
        case "unpavedroads":
            self = .unpavedRoads
        case "carpools":
            self = .carpools
        case "alreadyusedroads":
            self = .alreadyUsedRoads
        case "bordercrossings":
            self = .borderCrossings
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum RouteType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// The fastest route.
    case fastest
    /// The shortest route by distance.
    case shortest
    /// A route balanced by economy and speed.
    case economy
    /// Includes interesting or challenging roads and uses as few motorways as possible. You can choose the level of turns included and also the degree of hilliness. See the hilliness and windingness parameters for how to set this. There is a limit of 900 km on routes planned with `routeType`=thrilling
    case thrilling

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .fastest:
            return "fastest"
        case .shortest:
            return "shortest"
        case .economy:
            return "eco"
        case .thrilling:
            return "thrilling"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "fastest":
            self = .fastest
        case "shortest":
            self = .shortest
        case "eco":
            self = .economy
        case "thrilling":
            self = .thrilling
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum VehicleLoadType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Explosives
    case uSHazmatClass1
    /// Compressed gas
    case uSHazmatClass2
    /// Flammable liquids
    case uSHazmatClass3
    /// Flammable solids
    case uSHazmatClass4
    /// Oxidizers
    case uSHazmatClass5
    /// Poisons
    case uSHazmatClass6
    /// Radioactive
    case uSHazmatClass7
    /// Corrosives
    case uSHazmatClass8
    /// Miscellaneous
    case uSHazmatClass9
    /// Explosives
    case otherHazmatExplosive
    /// Miscellaneous
    case otherHazmatGeneral
    /// Harmful to water
    case otherHazmatHarmfulToWater

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .uSHazmatClass1:
            return "USHazmatClass1"
        case .uSHazmatClass2:
            return "USHazmatClass2"
        case .uSHazmatClass3:
            return "USHazmatClass3"
        case .uSHazmatClass4:
            return "USHazmatClass4"
        case .uSHazmatClass5:
            return "USHazmatClass5"
        case .uSHazmatClass6:
            return "USHazmatClass6"
        case .uSHazmatClass7:
            return "USHazmatClass7"
        case .uSHazmatClass8:
            return "USHazmatClass8"
        case .uSHazmatClass9:
            return "USHazmatClass9"
        case .otherHazmatExplosive:
            return "otherHazmatExplosive"
        case .otherHazmatGeneral:
            return "otherHazmatGeneral"
        case .otherHazmatHarmfulToWater:
            return "otherHazmatHarmfulToWater"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "ushazmatclass1":
            self = .uSHazmatClass1
        case "ushazmatclass2":
            self = .uSHazmatClass2
        case "ushazmatclass3":
            self = .uSHazmatClass3
        case "ushazmatclass4":
            self = .uSHazmatClass4
        case "ushazmatclass5":
            self = .uSHazmatClass5
        case "ushazmatclass6":
            self = .uSHazmatClass6
        case "ushazmatclass7":
            self = .uSHazmatClass7
        case "ushazmatclass8":
            self = .uSHazmatClass8
        case "ushazmatclass9":
            self = .uSHazmatClass9
        case "otherhazmatexplosive":
            self = .otherHazmatExplosive
        case "otherhazmatgeneral":
            self = .otherHazmatGeneral
        case "otherhazmatharmfultowater":
            self = .otherHazmatHarmfulToWater
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum ResponseFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259)
    case json
    /// [The Extensible Markup Language](https://www.w3.org/TR/xml/)
    case xml

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .json:
            return "json"
        case .xml:
            return "xml"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "json":
            self = .json
        case "xml":
            self = .xml
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum AlternativeRouteType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Allow any alternative route to be returned irrespective of how it compares to the reference route in terms of optimality.
    case anyRoute
    /// Return an alternative route only if it is better than the reference route according to the given planning criteria.
    case betterRoute

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .anyRoute:
            return "anyRoute"
        case .betterRoute:
            return "betterRoute"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "anyroute":
            self = .anyRoute
        case "betterroute":
            self = .betterRoute
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum RouteInstructionsType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Returns raw instruction data without human-readable messages.
    case coded
    /// Returns raw instructions data with human-readable messages in plain text.
    case text
    /// Returns raw instruction data with tagged human-readable messages to permit formatting. A human-readable message is built up from repeatable identified elements. These are tagged to allow client applications to format them correctly. The following message components are tagged when instructionsType=tagged: street, roadNumber, signpostText, exitNumber, roundaboutExitNumber.
    /// Example of tagged 'Turn left' message:â€‹
    /// ```
    /// Turn left onto <roadNumber>A4</roadNumber>/<roadNumber>E19</roadNumber>
    /// towards <signpostText>Den Haag</signpostText>
    /// ```
    case tagged

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .coded:
            return "coded"
        case .text:
            return "text"
        case .tagged:
            return "tagged"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "coded":
            self = .coded
        case "text":
            self = .text
        case "tagged":
            self = .tagged
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum RouteRepresentationForBestOrder: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Includes route geometry in the response.
    case polyline
    /// Summary as per polyline but excluding the point geometry elements for the routes in the response.
    case summaryOnly
    /// Includes only the optimized waypoint indices but does not include the route geometry in the response.
    case none

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .polyline:
            return "polyline"
        case .summaryOnly:
            return "summaryOnly"
        case .none:
            return "none"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "polyline":
            self = .polyline
        case "summaryonly":
            self = .summaryOnly
        case "none":
            self = .none
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum Report: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Reports the effective parameters or data used when calling the API.
    case effectiveSettings

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .effectiveSettings:
            return "effectiveSettings"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "effectivesettings":
            self = .effectiveSettings
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum VehicleEngineType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Internal combustion engine.
    case combustion
    /// Electric engine.
    case electric

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .combustion:
            return "combustion"
        case .electric:
            return "electric"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "combustion":
            self = .combustion
        case "electric":
            self = .electric
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Section types of the reported route response
public enum ResponseSectionType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Sections of the route that are cars or trains.
    case carOrTrain
    /// Sections indicating which countries the route is in.
    case country
    /// Sections of the route that are ferries.
    case ferry
    /// Sections of the route that are motorways.
    case motorway
    /// Sections of the route that are only suited for pedestrians.
    case pedestrian
    /// Sections of the route that require a toll to be payed.
    case tollRoad
    /// Sections of the route that require a toll vignette to be present.
    case tollVignette
    /// Sections of the route that contain traffic information.
    case traffic
    /// Sections in relation to the request parameter `travelMode`.
    case travelMode
    /// Sections of the route that are tunnels.
    case tunnel
    /// Sections of the route that require use of carpool (HOV/High Occupancy Vehicle) lanes.
    case carpool
    /// Sections of the route that are located within urban areas.
    case urban

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .carOrTrain:
            return "CAR_TRAIN"
        case .country:
            return "COUNTRY"
        case .ferry:
            return "FERRY"
        case .motorway:
            return "MOTORWAY"
        case .pedestrian:
            return "PEDESTRIAN"
        case .tollRoad:
            return "TOLL_ROAD"
        case .tollVignette:
            return "TOLL_VIGNETTE"
        case .traffic:
            return "TRAFFIC"
        case .travelMode:
            return "TRAVEL_MODE"
        case .tunnel:
            return "TUNNEL"
        case .carpool:
            return "CARPOOL"
        case .urban:
            return "URBAN"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "car_train":
            self = .carOrTrain
        case "country":
            self = .country
        case "ferry":
            self = .ferry
        case "motorway":
            self = .motorway
        case "pedestrian":
            self = .pedestrian
        case "toll_road":
            self = .tollRoad
        case "toll_vignette":
            self = .tollVignette
        case "traffic":
            self = .traffic
        case "travel_mode":
            self = .travelMode
        case "tunnel":
            self = .tunnel
        case "carpool":
            self = .carpool
        case "urban":
            self = .urban
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Travel mode for the calculated route. The value will be set to `other` if the requested mode of transport is not possible in this section
public enum ResponseTravelMode: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// The returned routes are optimized for cars.
    case car
    /// The returned routes are optimized for commercial vehicles, like for trucks.
    case truck
    /// The returned routes are optimized for taxis. BETA functionality.
    case taxi
    /// The returned routes are optimized for buses, including the use of bus only lanes. BETA functionality.
    case bus
    /// The returned routes are optimized for vans. BETA functionality.
    case van
    /// The returned routes are optimized for motorcycles. BETA functionality.
    case motorcycle
    /// The returned routes are optimized for bicycles, including use of bicycle lanes.
    case bicycle
    /// The returned routes are optimized for pedestrians, including the use of sidewalks.
    case pedestrian
    /// The given mode of transport is not possible in this section
    case other

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .car:
            return "car"
        case .truck:
            return "truck"
        case .taxi:
            return "taxi"
        case .bus:
            return "bus"
        case .van:
            return "van"
        case .motorcycle:
            return "motorcycle"
        case .bicycle:
            return "bicycle"
        case .pedestrian:
            return "pedestrian"
        case .other:
            return "other"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "car":
            self = .car
        case "truck":
            self = .truck
        case "taxi":
            self = .taxi
        case "bus":
            self = .bus
        case "van":
            self = .van
        case "motorcycle":
            self = .motorcycle
        case "bicycle":
            self = .bicycle
        case "pedestrian":
            self = .pedestrian
        case "other":
            self = .other
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Type of the incident. Can currently be JAM, ROAD_WORK, ROAD_CLOSURE, or OTHER. See "tec" for detailed information.
public enum SimpleCategory: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Traffic jam.
    case jam
    /// Road work.
    case roadWork
    /// Road closure.
    case roadClosure
    /// Other.
    case other

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .jam:
            return "JAM"
        case .roadWork:
            return "ROAD_WORK"
        case .roadClosure:
            return "ROAD_CLOSURE"
        case .other:
            return "OTHER"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "jam":
            self = .jam
        case "road_work":
            self = .roadWork
        case "road_closure":
            self = .roadClosure
        case "other":
            self = .other
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// The magnitude of delay caused by the incident. These values correspond to the values of the response field ty of the [Get Traffic Incident Detail API](https://docs.microsoft.com/rest/api/maps/traffic/gettrafficincidentdetail).
public enum DelayMagnitude: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Unknown.
    case unknown
    /// Minor.
    case minor
    /// Moderate.
    case moderate
    /// Major.
    case major
    /// Undefined, used for road closures and other indefinite delays.
    case undefined

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .unknown:
            return "0"
        case .minor:
            return "1"
        case .moderate:
            return "2"
        case .major:
            return "3"
        case .undefined:
            return "4"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .unknown
        case "1":
            self = .minor
        case "2":
            self = .moderate
        case "3":
            self = .major
        case "4":
            self = .undefined
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Type of the instruction, e.g., turn or change of road form.
public enum GuidanceInstructionType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Turn.
    case turn
    /// Road Change.
    case roadChange
    /// Departure location.
    case locationDeparture
    /// Arrival location.
    case locationArrival
    /// Direction information.
    case directionInfo
    /// Way point location.
    case locationWaypoint

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .turn:
            return "TURN"
        case .roadChange:
            return "ROAD_CHANGE"
        case .locationDeparture:
            return "LOCATION_DEPARTURE"
        case .locationArrival:
            return "LOCATION_ARRIVAL"
        case .directionInfo:
            return "DIRECTION_INFO"
        case .locationWaypoint:
            return "LOCATION_WAYPOINT"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "turn":
            self = .turn
        case "road_change":
            self = .roadChange
        case "location_departure":
            self = .locationDeparture
        case "location_arrival":
            self = .locationArrival
        case "direction_info":
            self = .directionInfo
        case "location_waypoint":
            self = .locationWaypoint
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout.
public enum JunctionType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// regular
    case regular
    /// roundabout
    case roundabout
    /// bifurcation
    case bifurcation

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .regular:
            return "REGULAR"
        case .roundabout:
            return "ROUNDABOUT"
        case .bifurcation:
            return "BIFURCATION"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "regular":
            self = .regular
        case "roundabout":
            self = .roundabout
        case "bifurcation":
            self = .bifurcation
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Indicates left-hand vs. right-hand side driving at the point of the maneuver.
public enum DrivingSide: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Left side.
    case left
    /// Right side.
    case right

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .left:
            return "LEFT"
        case .right:
            return "RIGHT"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "left":
            self = .left
        case "right":
            self = .right
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// A code identifying the maneuver.
public enum GuidanceManeuver: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// You have arrived.
    case arrive
    /// You have arrived. Your destination is on the left.
    case arriveLeft
    /// You have arrived. Your destination is on the right.
    case arriveRight
    /// Leave.
    case depart
    /// Keep straight on.
    case straight
    /// Keep right.
    case keepRight
    /// Bear right.
    case bearRight
    /// Turn right.
    case turnRight
    /// Turn sharp right.
    case sharpRight
    /// Keep left.
    case keepLeft
    /// Bear left.
    case bearLeft
    /// Turn left.
    case turnLeft
    /// Turn sharp left.
    case sharpLeft
    /// Make a U-turn.
    case makeUTurn
    /// Take the motorway.
    case enterMotorway
    /// Take the freeway.
    case enterFreeway
    /// Take the highway.
    case enterHighway
    /// Take the exit.
    case takeExit
    /// Take the left exit.
    case motorwayExitLeft
    /// Take the right exit.
    case motorwayExitRight
    /// Take the ferry.
    case takeFerry
    /// Cross the roundabout.
    case roundaboutCross
    /// At the roundabout take the exit on the right.
    case roundaboutRight
    /// At the roundabout take the exit on the left.
    case roundaboutLeft
    /// Go around the roundabout.
    case roundaboutBack
    /// Try to make a U-turn.
    case tryMakeUTurn
    /// Follow.
    case follow
    /// Switch to the parallel road.
    case switchParallelRoad
    /// Switch to the main road.
    case switchMainRoad
    /// Take the ramp.
    case entranceRamp
    /// You have reached the waypoint. It is on the left.
    case waypointLeft
    /// You have reached the waypoint. It is on the right.
    case waypointRight
    /// You have reached the waypoint.
    case waypointReached

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .arrive:
            return "ARRIVE"
        case .arriveLeft:
            return "ARRIVE_LEFT"
        case .arriveRight:
            return "ARRIVE_RIGHT"
        case .depart:
            return "DEPART"
        case .straight:
            return "STRAIGHT"
        case .keepRight:
            return "KEEP_RIGHT"
        case .bearRight:
            return "BEAR_RIGHT"
        case .turnRight:
            return "TURN_RIGHT"
        case .sharpRight:
            return "SHARP_RIGHT"
        case .keepLeft:
            return "KEEP_LEFT"
        case .bearLeft:
            return "BEAR_LEFT"
        case .turnLeft:
            return "TURN_LEFT"
        case .sharpLeft:
            return "SHARP_LEFT"
        case .makeUTurn:
            return "MAKE_UTURN"
        case .enterMotorway:
            return "ENTER_MOTORWAY"
        case .enterFreeway:
            return "ENTER_FREEWAY"
        case .enterHighway:
            return "ENTER_HIGHWAY"
        case .takeExit:
            return "TAKE_EXIT"
        case .motorwayExitLeft:
            return "MOTORWAY_EXIT_LEFT"
        case .motorwayExitRight:
            return "MOTORWAY_EXIT_RIGHT"
        case .takeFerry:
            return "TAKE_FERRY"
        case .roundaboutCross:
            return "ROUNDABOUT_CROSS"
        case .roundaboutRight:
            return "ROUNDABOUT_RIGHT"
        case .roundaboutLeft:
            return "ROUNDABOUT_LEFT"
        case .roundaboutBack:
            return "ROUNDABOUT_BACK"
        case .tryMakeUTurn:
            return "TRY_MAKE_UTURN"
        case .follow:
            return "FOLLOW"
        case .switchParallelRoad:
            return "SWITCH_PARALLEL_ROAD"
        case .switchMainRoad:
            return "SWITCH_MAIN_ROAD"
        case .entranceRamp:
            return "ENTRANCE_RAMP"
        case .waypointLeft:
            return "WAYPOINT_LEFT"
        case .waypointRight:
            return "WAYPOINT_RIGHT"
        case .waypointReached:
            return "WAYPOINT_REACHED"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "arrive":
            self = .arrive
        case "arrive_left":
            self = .arriveLeft
        case "arrive_right":
            self = .arriveRight
        case "depart":
            self = .depart
        case "straight":
            self = .straight
        case "keep_right":
            self = .keepRight
        case "bear_right":
            self = .bearRight
        case "turn_right":
            self = .turnRight
        case "sharp_right":
            self = .sharpRight
        case "keep_left":
            self = .keepLeft
        case "bear_left":
            self = .bearLeft
        case "turn_left":
            self = .turnLeft
        case "sharp_left":
            self = .sharpLeft
        case "make_uturn":
            self = .makeUTurn
        case "enter_motorway":
            self = .enterMotorway
        case "enter_freeway":
            self = .enterFreeway
        case "enter_highway":
            self = .enterHighway
        case "take_exit":
            self = .takeExit
        case "motorway_exit_left":
            self = .motorwayExitLeft
        case "motorway_exit_right":
            self = .motorwayExitRight
        case "take_ferry":
            self = .takeFerry
        case "roundabout_cross":
            self = .roundaboutCross
        case "roundabout_right":
            self = .roundaboutRight
        case "roundabout_left":
            self = .roundaboutLeft
        case "roundabout_back":
            self = .roundaboutBack
        case "try_make_uturn":
            self = .tryMakeUTurn
        case "follow":
            self = .follow
        case "switch_parallel_road":
            self = .switchParallelRoad
        case "switch_main_road":
            self = .switchMainRoad
        case "entrance_ramp":
            self = .entranceRamp
        case "waypoint_left":
            self = .waypointLeft
        case "waypoint_right":
            self = .waypointRight
        case "waypoint_reached":
            self = .waypointReached
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Specifies the `GeoJSON` type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection, Feature and FeatureCollection.
public enum GeoJsonObjectType: String, Codable, RequestStringConvertible {
    /// `GeoJSON Point` geometry.
    case geoJsonPoint = "Point"
    /// `GeoJSON MultiPoint` geometry.
    case geoJsonMultiPoint = "MultiPoint"
    /// `GeoJSON LineString` geometry.
    case geoJsonLineString = "LineString"
    /// `GeoJSON MultiLineString` geometry.
    case geoJsonMultiLineString = "MultiLineString"
    /// `GeoJSON Polygon` geometry.
    case geoJsonPolygon = "Polygon"
    /// `GeoJSON MultiPolygon` geometry.
    case geoJsonMultiPolygon = "MultiPolygon"
    /// `GeoJSON GeometryCollection` geometry.
    case geoJsonGeometryCollection = "GeometryCollection"
    /// `GeoJSON Feature` object.
    case geoJsonFeature = "Feature"
    /// `GeoJSON FeatureCollection` object.
    case geoJsonFeatureCollection = "FeatureCollection"

    public var requestString: String {
        return rawValue
    }
}
